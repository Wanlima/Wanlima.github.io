(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{366:function(t,e,s){"use strict";s.r(e);var r=s(44),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"类别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类别"}},[t._v("#")]),t._v(" 类别")]),t._v(" "),s("p",[t._v("在类别中添加属性：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("@interface People (Category)\n\n@property (nonatomic, copy) NSString *sname;\n\n@end\n\n")])])]),s("p",[t._v("在调用属性的"),s("code",[t._v("setter")]),t._v("和"),s("code",[t._v("getter")]),t._v("方法时会 "),s("strong",[t._v("Crash")]),t._v(" ：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("OCTest[18213:2605018] -[People setSname:]: unrecognized selector sent to instance 0x7b080007be00\n\nOCTest[18339:2610326] -[People sname]: unrecognized selector sent to instance 0x7b080007c0c0\n")])])]),s("p",[s("strong",[t._v("类别为什么不能添加属性？")])]),t._v(" "),s("p",[t._v("看一下 "),s("code",[t._v("Category")]),t._v(" 的结构体：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("struct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n    // Fields below this point are not always present on disk.\n    struct property_list_t *_classProperties;\n};\n")])])]),s("p",[t._v("分类结构体包含 类名、cls、实例方法列表、类方法列表、协议列表、属性列表。")]),t._v(" "),s("blockquote",[s("p",[t._v("我们知道 "),s("code",[t._v("Property")]),t._v(" 的本质是 "),s("code",[t._v("成员变量+存取方法")]),t._v("（ivar、getter/setter），"),s("code",[t._v("@synthesize")]),t._v(" 是Xcode编译器特性，它会自动生成ivar、getter/setter。")]),t._v(" "),s("p",[t._v("dyld加载期间，类别才会被加载并"),s("code",[t._v("attach")]),t._v("到相应的类中，这是一个动态的过程，"),s("code",[t._v("成员变量")]),t._v("不能动态添加，因为表示"),s("code",[t._v("OC")]),t._v("类的结构体在运行时并不能改变。类别的结构体中虽然有属性列表，但是这些属性不会自动生成"),s("code",[t._v("成员变量")]),t._v("，自然也就不会合成存取方法，也就是不具备"),s("code",[t._v("@synthesize")]),t._v("的作用。")])]),t._v(" "),s("p",[s("strong",[t._v("分类的作用：")])]),t._v(" "),s("blockquote",[s("p",[t._v("不改变原有类，给这个类扩展方法。")])]),t._v(" "),s("p",[s("strong",[t._v("类别和扩展的区别？")])]),t._v(" "),s("p",[t._v("两者的区别：")]),t._v(" "),s("ul",[s("li",[t._v("分类是运行时决议，扩展是编译时决议；")]),t._v(" "),s("li",[t._v("分类可以添加方法，通过关联对象添加成员变量，扩展可以添加属性。")]),t._v(" "),s("li",[t._v("分类既有声明头文件也有实现文件，扩展只有声明头文件，实现在类的.m文件中；")])]),t._v(" "),s("p",[s("strong",[t._v("类别中的方法什么时候开始合并的？")])]),t._v(" "),s("blockquote",[s("p",[t._v("分类是在运行时将方法列表与类的原有方法列表合并，且分类中的方法在前。")])]),t._v(" "),s("p",[s("strong",[t._v("参考：")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.zhihu.com/question/51513146/answer/126443097",target:"_blank",rel:"noopener noreferrer"}},[t._v("iOS 类别不能添加属性原理？"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.jianshu.com/p/fa66c8be42a2",target:"_blank",rel:"noopener noreferrer"}},[t._v("iOS Category的本质"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.jianshu.com/writer#/notebooks/23278598/notes/31347042/preview",target:"_blank",rel:"noopener noreferrer"}},[t._v("Category原理"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);